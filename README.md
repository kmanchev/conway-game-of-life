# conway-game-of-life
Scheme implementation of **Conway's Game of Life**

# 1.Регламент на играта: 
Поле с размер NxN и клетки със стойности между 0 и 1 .
1 - жива клетка.
0 - мъртва клетка.
Полето се обновява на ходове.
Когато в съседство на мъртва клетка има точно 3 живи клетки, на следващия ход клетката променя състоянието си от мъртва на жива.
Когат в съседство на жива клетка има по малко от 2 или повече от 3 живи клетки, тя умира на следващия ход.
Когато в съседство на жива клета има 2/3 живи клетки, на следващия ход запазва състоянието си 
# 2.Реализация
Проектът е имплементиран на **Scheme**.
Полето се репрезентира с лист от листове образуващи матрица от елементи. Идеята е да изчислим следващото състояние на полето като обходим всеки ред на матрицата и проверим за всеки елемент индивидуалното състояние. Играта се стартира от метода  **conway-game** приемащ 2 аргумента - **board** (начално състояние на дъската) и **reps** (брой повторения за които искаме да мутираме дъската). Метода сам по себе си извиква **print-board** (отпечатваме моментното състояние на дъската) и извиква рекурсивно себе си с параметър функцията **next-step** и с понижен параметър за повторения. 
**next-step** - пресмята следващото състояние на дъската. Приема като аргумент матрицата от елементи (лист от листове) и извиква helper метод който приема 4 аргумента 2 пъти редовете на матрицата (единия ще ползваме да итерираме по него, другия ще се използва за проверка на съседите изчисляване на състоянието на отделните клетки), индекс (за да следим на кой елемент сме във всеки един момент- ще се използва при статусите на съседите ), и празен лист (в него ще трупаме резултата за новата дъска ) 
**next-step-helper** - итерира всички редове и пресмята новите редове и ги натрупва в аргумента res (result).
**compute-row** - пресмята състоянието на реда за следващия ход спрямо състоянието на стария и съседите му. Приема като параметри текущия ред, индекса на текущия ред и всички редове (текущото състояние на дъската). Метода изпълнява helper функция compute-row-helper.
**compute-row-helper** - приема като аргументи текущия ред, индекса на текущия ред, всички редове на текущото състояние на матрицата, индекс на текущия елемент който се обработва в реда, параметър за натрупване на резултата. Целта е метода да построи нов ред за новото състояние на матрицата. Всеки елемент се изчислява чрез метода **compute-elem**.
**compute-elem** - приема като аргументи текущия елемент, индекса на ред който се обработва, всички редове на текущото състояние на матрицата, индекс на елемента който се обработва. Метода прави проверка на съседите на елемента и спрямо резултата връща новото му състояние. Проверката на съседите се осъществява с метода **count-neighbours**.
**count-neighbours** - приема като аргументи текущия елемент, индекса на ред който се обработва, всички редове на текущото състояние на матрицата, индекс на елемента който се обработва. Целта на този метод е да вземе всички обкръжаващи дадения елемент съседи и да изчисли сбора на живите. Вземането на всеки съсед се осъществява с метода **get-matrix-elem-by-indexes**.
**get-matrix-elem-by-indexes** - приема като аргументи всички редове на текущото състояние и x и y координати с които посочваме кой елемент искаме да достъпим.
